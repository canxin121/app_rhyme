// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::api::music_api::wrapper::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.8.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 1258401814;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__music_api__wrapper__MusicDataJsonWrapper_apply_to_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MusicDataJsonWrapper_apply_to_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <MusicDataJsonWrapper>::sse_decode(&mut deserializer);
            let api_playlist_id = <Option<i64>>::sse_decode(&mut deserializer);
            let api_playlist_collection_id = <Option<i64>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::wrapper::MusicDataJsonWrapper::apply_to_db(
                                api_that,
                                api_playlist_id,
                                api_playlist_collection_id,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__wrapper__MusicDataJsonWrapper_from_database_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MusicDataJsonWrapper_from_database",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::wrapper::MusicDataJsonWrapper::from_database()
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__wrapper__MusicDataJsonWrapper_from_json_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MusicDataJsonWrapper_from_json",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_json = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::music_api::wrapper::MusicDataJsonWrapper::from_json(
                                &api_json,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__music_api__wrapper__MusicDataJsonWrapper_from_music_aggregators_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MusicDataJsonWrapper_from_music_aggregators", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_music_aggregators = <Vec<crate::api::music_api::mirror::MusicAggregator>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move || async move {
                         let output_ok = crate::api::music_api::wrapper::MusicDataJsonWrapper::from_music_aggregators(api_music_aggregators).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__music_api__wrapper__MusicDataJsonWrapper_from_playlists_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MusicDataJsonWrapper_from_playlists",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_playlists =
                <Vec<crate::api::music_api::mirror::Playlist>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::wrapper::MusicDataJsonWrapper::from_playlists(
                                api_playlists,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__wrapper__MusicDataJsonWrapper_get_type_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MusicDataJsonWrapper_get_type",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MusicDataJsonWrapper>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::music_api::wrapper::MusicDataJsonWrapper::get_type(
                            &*api_that_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__music_api__wrapper__MusicDataJsonWrapper_load_from_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MusicDataJsonWrapper_load_from",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::wrapper::MusicDataJsonWrapper::load_from(
                                &api_path,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__wrapper__MusicDataJsonWrapper_save_to_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MusicDataJsonWrapper_save_to",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MusicDataJsonWrapper>,
            >>::sse_decode(&mut deserializer);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::music_api::wrapper::MusicDataJsonWrapper::save_to(
                                &*api_that_guard,
                                &api_path,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__wrapper__MusicDataJsonWrapper_to_json_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MusicDataJsonWrapper_to_json",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MusicDataJsonWrapper>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            crate::api::music_api::wrapper::MusicDataJsonWrapper::to_json(
                                &*api_that_guard,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__cache__file_cache__cache_file_from_content_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cache_file_from_content",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_document_folder = <String>::sse_decode(&mut deserializer);
            let api_content = <String>::sse_decode(&mut deserializer);
            let api_cache_folder = <String>::sse_decode(&mut deserializer);
            let api_filename = <String>::sse_decode(&mut deserializer);
            let api_custom_cache_root = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::cache::file_cache::cache_file_from_content(
                            &api_document_folder,
                            api_content,
                            &api_cache_folder,
                            api_filename,
                            &api_custom_cache_root,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__cache__file_cache__cache_file_from_uri_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cache_file_from_uri",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_document_folder = <String>::sse_decode(&mut deserializer);
            let api_uri = <String>::sse_decode(&mut deserializer);
            let api_cache_folder = <String>::sse_decode(&mut deserializer);
            let api_filename = <Option<String>>::sse_decode(&mut deserializer);
            let api_custom_cache_root = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::cache::file_cache::cache_file_from_uri(
                            &api_document_folder,
                            &api_uri,
                            &api_cache_folder,
                            &api_filename,
                            &api_custom_cache_root,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__cache__music_cache__cache_music_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cache_music",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_document_folder = <String>::sse_decode(&mut deserializer);
            let api_custom_cache_root = <Option<String>>::sse_decode(&mut deserializer);
            let api_name = <String>::sse_decode(&mut deserializer);
            let api_artists = <String>::sse_decode(&mut deserializer);
            let api_playinfo =
                <crate::api::types::playinfo::PlayInfo>::sse_decode(&mut deserializer);
            let api_lyric = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::cache::music_cache::cache_music(
                            &api_document_folder,
                            &api_custom_cache_root,
                            api_name,
                            api_artists,
                            api_playinfo,
                            api_lyric,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__types__version__check_update_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "check_update",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_current_version = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::types::version::check_update(&api_current_version).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__fns__clear_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clear_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::music_api::fns::clear_db().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__fns__close_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "close_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::music_api::fns::close_db().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__types__config__config_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "config_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::types::config::Config::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__config__config_get_sql_url_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "config_get_sql_url",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::types::config::Config>::sse_decode(&mut deserializer);
            let api_document_folder = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::types::config::Config::get_sql_url(
                        &api_that,
                        &api_document_folder,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__types__config__config_get_storage_folder_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "config_get_storage_folder",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::types::config::Config>::sse_decode(&mut deserializer);
            let api_document_folder = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::types::config::Config::get_storage_folder(
                        &api_that,
                        &api_document_folder,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__types__config__config_load_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "config_load",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_document_folder = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::types::config::Config::load(&api_document_folder).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__types__config__config_save_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "config_save",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::types::config::Config>::sse_decode(&mut deserializer);
            let api_document_folder = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::types::config::Config::save(
                            &api_that,
                            &api_document_folder,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__cache__cache_util__delete_cache_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "delete_cache_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_document_path = <String>::sse_decode(&mut deserializer);
            let api_custom_cache_root = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::cache::cache_util::delete_cache_data(
                            &api_document_path,
                            api_custom_cache_root,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__cache__file_cache__delete_cache_file_with_uri_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "delete_cache_file_with_uri",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_document_folder = <String>::sse_decode(&mut deserializer);
            let api_uri = <String>::sse_decode(&mut deserializer);
            let api_cache_folder = <String>::sse_decode(&mut deserializer);
            let api_filename = <Option<String>>::sse_decode(&mut deserializer);
            let api_custom_cache_root = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::cache::file_cache::delete_cache_file_with_uri(
                            &api_document_folder,
                            &api_uri,
                            &api_cache_folder,
                            &api_filename,
                            &api_custom_cache_root,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__cache__music_cache__delete_music_cache_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "delete_music_cache",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_document_folder = <String>::sse_decode(&mut deserializer);
            let api_custom_cache_root = <Option<String>>::sse_decode(&mut deserializer);
            let api_name = <String>::sse_decode(&mut deserializer);
            let api_artists = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::cache::music_cache::delete_music_cache(
                            &api_document_folder,
                            &api_custom_cache_root,
                            &api_name,
                            &api_artists,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__types__external_api__external_api_config_fetch_update_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "external_api_config_fetch_update",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::types::external_api::ExternalApiConfig>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::types::external_api::ExternalApiConfig::fetch_update(
                                &api_that,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__types__external_api__external_api_config_from_path_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "external_api_config_from_path",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_path = <String>::sse_decode(&mut deserializer);
            let api_document_folder = <String>::sse_decode(&mut deserializer);
            let api_custom_cache_root = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::types::external_api::ExternalApiConfig::from_path(
                                &api_path,
                                &api_document_folder,
                                &api_custom_cache_root,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__types__external_api__external_api_config_from_url_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "external_api_config_from_url",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_url = <String>::sse_decode(&mut deserializer);
            let api_document_folder = <String>::sse_decode(&mut deserializer);
            let api_custom_cache_root = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::types::external_api::ExternalApiConfig::from_url(
                                &api_url,
                                &api_document_folder,
                                &api_custom_cache_root,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__cache__file_cache__gen_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "gen_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_str_ = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::cache::file_cache::gen_hash(&api_str_))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__utils__path_util__get_apprhyme_dir_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_apprhyme_dir",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_document_dir = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::utils::path_util::get_apprhyme_dir(api_document_dir)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__cache__file_cache__get_cache_file_from_uri_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_cache_file_from_uri",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_document_folder = <String>::sse_decode(&mut deserializer);
            let api_uri = <String>::sse_decode(&mut deserializer);
            let api_cache_folder = <String>::sse_decode(&mut deserializer);
            let api_filename = <Option<String>>::sse_decode(&mut deserializer);
            let api_custom_cache_root = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::cache::file_cache::get_cache_file_from_uri(
                        &api_document_folder,
                        &api_uri,
                        &api_cache_folder,
                        &api_filename,
                        &api_custom_cache_root,
                    ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__cache__music_cache__get_cache_music_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_cache_music",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_document_folder = <String>::sse_decode(&mut deserializer);
            let api_custom_cache_root = <Option<String>>::sse_decode(&mut deserializer);
            let api_name = <String>::sse_decode(&mut deserializer);
            let api_artists = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::cache::music_cache::get_cache_music(
                                &api_document_folder,
                                &api_custom_cache_root,
                                api_name,
                                api_artists,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__utils__path_util__get_log_dir_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_log_dir",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_document_dir = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::utils::path_util::get_log_dir(api_document_dir)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__types__version__get_release_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_release",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::types::version::get_release().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__cache__music_cache__has_cache_music_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "has_cache_music",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_document_folder = <String>::sse_decode(&mut deserializer);
            let api_custom_cache_root = <Option<String>>::sse_decode(&mut deserializer);
            let api_name = <String>::sse_decode(&mut deserializer);
            let api_artists = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::cache::music_cache::has_cache_music(
                                &api_document_folder,
                                &api_custom_cache_root,
                                api_name,
                                api_artists,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__init__init_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::init::init().await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__log__init_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::log::init().await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__init__init_backend_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_backend",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_document_folder = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::init::init_backend(api_document_folder).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__log__logger_debug_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "logger_debug",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::log::Logger>::sse_decode(&mut deserializer);
            let api_message = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::log::Logger::debug(&api_that, &api_message);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__log__logger_error_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "logger_error",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::log::Logger>::sse_decode(&mut deserializer);
            let api_message = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::log::Logger::error(&api_that, &api_message);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__log__logger_info_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "logger_info",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::log::Logger>::sse_decode(&mut deserializer);
            let api_message = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::log::Logger::info(&api_that, &api_message);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__log__logger_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "logger_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_log_dir = <String>::sse_decode(&mut deserializer);
            let api_max_level = <crate::api::log::LogLevel>::sse_decode(&mut deserializer);
            let api_max_log_size = <u64>::sse_decode(&mut deserializer);
            let api_max_log_files = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::log::Logger::new(
                            api_log_dir,
                            api_max_level,
                            api_max_log_size,
                            api_max_log_files,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__log__logger_warn_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "logger_warn",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::log::Logger>::sse_decode(&mut deserializer);
            let api_message = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::log::Logger::warn(&api_that, &api_message);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__cache__cache_util__move_cache_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "move_cache_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_document_path = <String>::sse_decode(&mut deserializer);
            let api_old_custom_cache_root = <Option<String>>::sse_decode(&mut deserializer);
            let api_new_custom_cache_root = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::cache::cache_util::move_cache_data(
                            &api_document_path,
                            api_old_custom_cache_root,
                            api_new_custom_cache_root,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__music_aggregator_change_default_server_in_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "music_aggregator_change_default_server_in_db", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::music_api::mirror::MusicAggregator>::sse_decode(&mut deserializer);
let api_server = <crate::api::music_api::mirror::MusicServer>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move || async move {
                         let output_ok = crate::api::music_api::mirror::MusicAggregator::change_default_server_in_db(&api_that, api_server).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__music_api__mirror__music_aggregator_clear_unused_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "music_aggregator_clear_unused",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::MusicAggregator::clear_unused().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__music_aggregator_del_from_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "music_aggregator_del_from_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::music_api::mirror::MusicAggregator>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::MusicAggregator::del_from_db(&api_that)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__music_aggregator_fetch_artist_music_aggregators_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "music_aggregator_fetch_artist_music_aggregators", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_server = <crate::api::music_api::mirror::MusicServer>::sse_decode(&mut deserializer);
let api_artist_id = <String>::sse_decode(&mut deserializer);
let api_page = <u16>::sse_decode(&mut deserializer);
let api_limit = <u16>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move || async move {
                         let output_ok = crate::api::music_api::mirror::MusicAggregator::fetch_artist_music_aggregators(api_server, &api_artist_id, api_page, api_limit).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__music_api__mirror__music_aggregator_fetch_server_online_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "music_aggregator_fetch_server_online",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::music_api::mirror::MusicAggregator>::sse_decode(&mut deserializer);
            let api_servers =
                <Vec<crate::api::music_api::mirror::MusicServer>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::MusicAggregator::fetch_server_online(
                                api_that,
                                api_servers,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__music_aggregator_from_music_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "music_aggregator_from_music",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_music = <crate::api::music_api::mirror::Music>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::music_api::mirror::MusicAggregator::from_music(api_music),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__music_aggregator_identity_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "music_aggregator_identity",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::music_api::mirror::MusicAggregator>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::music_api::mirror::MusicAggregator::identity(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__music_api__mirror__music_aggregator_save_to_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "music_aggregator_save_to_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::music_api::mirror::MusicAggregator>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::MusicAggregator::save_to_db(&api_that)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__music_aggregator_search_online_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "music_aggregator_search_online",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_aggs = <Vec<crate::api::music_api::mirror::MusicAggregator>>::sse_decode(
                &mut deserializer,
            );
            let api_servers =
                <Vec<crate::api::music_api::mirror::MusicServer>>::sse_decode(&mut deserializer);
            let api_content = <String>::sse_decode(&mut deserializer);
            let api_page = <u16>::sse_decode(&mut deserializer);
            let api_size = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::MusicAggregator::search_online(
                                api_aggs,
                                api_servers,
                                api_content,
                                api_page,
                                api_size,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__music_aggregator_update_order_to_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "music_aggregator_update_order_to_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::music_api::mirror::MusicAggregator>::sse_decode(&mut deserializer);
            let api_playlist_id = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::MusicAggregator::update_order_to_db(
                                &api_that,
                                api_playlist_id,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__music_get_album_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "music_get_album",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::music_api::mirror::Music>::sse_decode(&mut deserializer);
            let api_page = <u16>::sse_decode(&mut deserializer);
            let api_limit = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::music_api::mirror::Music::get_album(
                            &api_that, api_page, api_limit,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__music_get_cover_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "music_get_cover",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::music_api::mirror::Music>::sse_decode(&mut deserializer);
            let api_size = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::music_api::mirror::Music::get_cover(&api_that, api_size),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__music_api__mirror__music_get_lyric_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "music_get_lyric",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::music_api::mirror::Music>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::Music::get_lyric(&api_that).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__music_insert_to_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "music_insert_to_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::music_api::mirror::Music>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::Music::insert_to_db(&api_that).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__music_search_online_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "music_search_online",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_servers =
                <Vec<crate::api::music_api::mirror::MusicServer>>::sse_decode(&mut deserializer);
            let api_content = <String>::sse_decode(&mut deserializer);
            let api_page = <u16>::sse_decode(&mut deserializer);
            let api_size = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::music_api::mirror::Music::search_online(
                            api_servers,
                            api_content,
                            api_page,
                            api_size,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__music_server_all_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "music_server_all",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::music_api::mirror::MusicServer::all())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__music_api__mirror__music_server_length_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "music_server_length",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::music_api::mirror::MusicServer::length())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__music_api__mirror__music_server_to_string_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "music_server_to_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::music_api::mirror::MusicServer>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::music_api::mirror::MusicServer::to_string(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__music_api__plugin_fn__music_to_json_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "music_to_json",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_music = <crate::api::music_api::mirror::Music>::sse_decode(&mut deserializer);
            let api_quality =
                <crate::api::music_api::mirror::Quality>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::music_api::plugin_fn::music_to_json(
                            api_music,
                            api_quality,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__music_update_to_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "music_update_to_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::music_api::mirror::Music>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::Music::update_to_db(&api_that).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_add_aggs_to_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_add_aggs_to_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::music_api::mirror::Playlist>::sse_decode(&mut deserializer);
            let api_music_aggs = <Vec<crate::api::music_api::mirror::MusicAggregator>>::sse_decode(
                &mut deserializer,
            );
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::music_api::mirror::Playlist::add_aggs_to_db(
                            &api_that,
                            &api_music_aggs,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_collection_delete_from_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_collection_delete_from_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::music_api::mirror::PlaylistCollection>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::PlaylistCollection::delete_from_db(
                                &api_that,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_collection_find_in_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_collection_find_in_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_id = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::PlaylistCollection::find_in_db(api_id)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_collection_get_form_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_collection_get_form_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::PlaylistCollection::get_form_db()
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_collection_get_playlists_from_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "playlist_collection_get_playlists_from_db", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::music_api::mirror::PlaylistCollection>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move || async move {
                         let output_ok = crate::api::music_api::mirror::PlaylistCollection::get_playlists_from_db(&api_that).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__music_api__mirror__playlist_collection_insert_to_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_collection_insert_to_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::music_api::mirror::PlaylistCollection>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::PlaylistCollection::insert_to_db(
                                &api_that,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_collection_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_collection_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::music_api::mirror::PlaylistCollection::new(api_name),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_collection_update_to_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_collection_update_to_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::music_api::mirror::PlaylistCollection>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::PlaylistCollection::update_to_db(
                                &api_that,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_del_from_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_del_from_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::music_api::mirror::Playlist>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::Playlist::del_from_db(api_that).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_del_music_agg_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_del_music_agg",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::music_api::mirror::Playlist>::sse_decode(&mut deserializer);
            let api_music_agg_identity = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::music_api::mirror::Playlist::del_music_agg(
                            &api_that,
                            api_music_agg_identity,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_fetch_artist_albums_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_fetch_artist_albums",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_server =
                <crate::api::music_api::mirror::MusicServer>::sse_decode(&mut deserializer);
            let api_artist_id = <String>::sse_decode(&mut deserializer);
            let api_page = <u16>::sse_decode(&mut deserializer);
            let api_limit = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::Playlist::fetch_artist_albums(
                                api_server,
                                &api_artist_id,
                                api_page,
                                api_limit,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_fetch_musics_online_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_fetch_musics_online",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::music_api::mirror::Playlist>::sse_decode(&mut deserializer);
            let api_page = <u16>::sse_decode(&mut deserializer);
            let api_limit = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::Playlist::fetch_musics_online(
                                &api_that, api_page, api_limit,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_find_in_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_find_in_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_id = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::music_api::mirror::Playlist::find_in_db(api_id).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_get_cover_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_get_cover",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::music_api::mirror::Playlist>::sse_decode(&mut deserializer);
            let api_size = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::music_api::mirror::Playlist::get_cover(&api_that, api_size),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_get_from_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_get_from_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::Playlist::get_from_db().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_get_from_share_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_get_from_share",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_share = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::Playlist::get_from_share(&api_share)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_get_musics_from_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_get_musics_from_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::music_api::mirror::Playlist>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::Playlist::get_musics_from_db(&api_that)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_insert_to_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_insert_to_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::music_api::mirror::Playlist>::sse_decode(&mut deserializer);
            let api_collection_id = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::music_api::mirror::Playlist::insert_to_db(
                            &api_that,
                            api_collection_id,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_name = <String>::sse_decode(&mut deserializer);
            let api_summary = <Option<String>>::sse_decode(&mut deserializer);
            let api_cover = <Option<String>>::sse_decode(&mut deserializer);
            let api_subscriptions =
                <Vec<crate::api::music_api::mirror::PlayListSubscription>>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::music_api::mirror::Playlist::new(
                            api_name,
                            api_summary,
                            api_cover,
                            api_subscriptions,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_search_online_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_search_online",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_servers =
                <Vec<crate::api::music_api::mirror::MusicServer>>::sse_decode(&mut deserializer);
            let api_content = <String>::sse_decode(&mut deserializer);
            let api_page = <u16>::sse_decode(&mut deserializer);
            let api_size = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::music_api::mirror::Playlist::search_online(
                            api_servers,
                            api_content,
                            api_page,
                            api_size,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_update_subscription_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_update_subscription",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::music_api::mirror::Playlist>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::Playlist::update_subscription(&api_that)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__playlist_update_to_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "playlist_update_to_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::music_api::mirror::Playlist>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::mirror::Playlist::update_to_db(&api_that)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__types__config__quality_config_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "quality_config_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::types::config::QualityConfig::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__utils__crypto__rc4_decrypt_from_base64_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "rc4_decrypt_from_base64",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_key = <String>::sse_decode(&mut deserializer);
            let api_input = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::utils::crypto::rc4_decrypt_from_base64(
                            &api_key, &api_input,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__utils__crypto__rc4_encrypt_to_base64_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "rc4_encrypt_to_base64",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_key = <String>::sse_decode(&mut deserializer);
            let api_input = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::utils::crypto::rc4_encrypt_to_base64(&api_key, &api_input)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__fns__reinit_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "reinit_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::music_api::fns::reinit_db().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__log__save_log_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "save_log",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_document_dir = <String>::sse_decode(&mut deserializer);
            let api_output_dir = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::log::save_log(api_document_dir, api_output_dir).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__utils__http_helper__send_request_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "send_request",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_method = <String>::sse_decode(&mut deserializer);
            let api_headers =
                <std::collections::HashMap<String, String>>::sse_decode(&mut deserializer);
            let api_url = <String>::sse_decode(&mut deserializer);
            let api_payload = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::utils::http_helper::send_request(
                                &api_method,
                                api_headers,
                                &api_url,
                                &api_payload,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__music_api__mirror__server_music_chart_collection_get_music_chart_collection_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "server_music_chart_collection_get_music_chart_collection", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context| async move {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move || async move {
                         let output_ok = crate::api::music_api::mirror::ServerMusicChartCollection::get_music_chart_collection().await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__music_api__mirror__server_music_chart_collection_get_musics_from_chart_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "server_music_chart_collection_get_musics_from_chart", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_server = <crate::api::music_api::mirror::MusicServer>::sse_decode(&mut deserializer);
let api_id = <String>::sse_decode(&mut deserializer);
let api_page = <u16>::sse_decode(&mut deserializer);
let api_limit = <u16>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move || async move {
                         let output_ok = crate::api::music_api::mirror::ServerMusicChartCollection::get_musics_from_chart(api_server, &api_id, api_page, api_limit).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__music_api__mirror__server_playlist_tag_collection_get_playlist_tags_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "server_playlist_tag_collection_get_playlist_tags", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context| async move {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move || async move {
                         let output_ok = crate::api::music_api::mirror::ServerPlaylistTagCollection::get_playlist_tags().await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__music_api__mirror__server_playlist_tag_collection_get_playlists_from_tag_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "server_playlist_tag_collection_get_playlists_from_tag", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_server = <crate::api::music_api::mirror::MusicServer>::sse_decode(&mut deserializer);
let api_tag_id = <String>::sse_decode(&mut deserializer);
let api_order = <crate::api::music_api::mirror::TagPlaylistOrder>::sse_decode(&mut deserializer);
let api_page = <u16>::sse_decode(&mut deserializer);
let api_limit = <u16>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move || async move {
                         let output_ok = crate::api::music_api::mirror::ServerPlaylistTagCollection::get_playlists_from_tag(api_server, &api_tag_id, api_order, api_page, api_limit).await?;   Ok(output_ok)
                    })().await)
                } })
}
fn wire__crate__api__music_api__fns__set_db_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_db",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_database_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::music_api::fns::set_db(&api_database_url).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__types__config__storage_config_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "storage_config_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::types::config::StorageConfig::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__config__update_config_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "update_config_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::types::config::UpdateConfig::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__utils__path_util__url_encode_special_chars_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "url_encode_special_chars",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_input = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::utils::path_util::url_encode_special_chars(&api_input),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__utils__database__verify_sqlite_url_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "verify_sqlite_url",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sqlite_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::utils::database::verify_sqlite_url(api_sqlite_url).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__types__config__window_config_default_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "window_config_default",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::types::config::WindowConfig::default())?;
                Ok(output_ok)
            })())
        },
    )
}

// Section: static_checks

#[allow(clippy::unnecessary_literal_unwrap)]
const _: fn() = || {
    {
        let Artist = None::<crate::api::music_api::mirror::Artist>.unwrap();
        let _: String = Artist.name;
        let _: Option<String> = Artist.id;
    }
    {
        let Music = None::<crate::api::music_api::mirror::Music>.unwrap();
        let _: bool = Music.from_db;
        let _: crate::api::music_api::mirror::MusicServer = Music.server;
        let _: String = Music.identity;
        let _: String = Music.name;
        let _: Option<i64> = Music.duration;
        let _: Vec<crate::api::music_api::mirror::Artist> = Music.artists;
        let _: Option<String> = Music.album;
        let _: Option<String> = Music.album_id;
        let _: Vec<crate::api::music_api::mirror::Quality> = Music.qualities;
        let _: Option<String> = Music.cover;
    }
    {
        let MusicAggregator = None::<crate::api::music_api::mirror::MusicAggregator>.unwrap();
        let _: String = MusicAggregator.name;
        let _: String = MusicAggregator.artist;
        let _: bool = MusicAggregator.from_db;
        let _: Option<i64> = MusicAggregator.order;
        let _: Vec<crate::api::music_api::mirror::Music> = MusicAggregator.musics;
        let _: crate::api::music_api::mirror::MusicServer = MusicAggregator.default_server;
    }
    {
        let MusicChart = None::<crate::api::music_api::mirror::MusicChart>.unwrap();
        let _: String = MusicChart.name;
        let _: Option<String> = MusicChart.summary;
        let _: Option<String> = MusicChart.cover;
        let _: String = MusicChart.id;
    }
    {
        let MusicChartCollection =
            None::<crate::api::music_api::mirror::MusicChartCollection>.unwrap();
        let _: String = MusicChartCollection.name;
        let _: Option<String> = MusicChartCollection.summary;
        let _: Vec<crate::api::music_api::mirror::MusicChart> = MusicChartCollection.charts;
    }
    {
        let PlayListSubscription =
            None::<crate::api::music_api::mirror::PlayListSubscription>.unwrap();
        let _: String = PlayListSubscription.name;
        let _: String = PlayListSubscription.share;
    }
    {
        let Playlist = None::<crate::api::music_api::mirror::Playlist>.unwrap();
        let _: bool = Playlist.from_db;
        let _: Option<crate::api::music_api::mirror::MusicServer> = Playlist.server;
        let _: crate::api::music_api::mirror::PlaylistType = Playlist.type_field;
        let _: String = Playlist.identity;
        let _: Option<i64> = Playlist.collection_id;
        let _: String = Playlist.name;
        let _: Option<i64> = Playlist.order;
        let _: Option<String> = Playlist.summary;
        let _: Option<String> = Playlist.cover;
        let _: Option<String> = Playlist.creator;
        let _: Option<String> = Playlist.creator_id;
        let _: Option<i64> = Playlist.play_time;
        let _: Option<i64> = Playlist.music_num;
        let _: Option<Vec<crate::api::music_api::mirror::PlayListSubscription>> =
            Playlist.subscription;
    }
    {
        let PlaylistCollection = None::<crate::api::music_api::mirror::PlaylistCollection>.unwrap();
        let _: i64 = PlaylistCollection.id;
        let _: i64 = PlaylistCollection.order;
        let _: String = PlaylistCollection.name;
    }
    {
        let PlaylistTag = None::<crate::api::music_api::mirror::PlaylistTag>.unwrap();
        let _: String = PlaylistTag.name;
        let _: String = PlaylistTag.id;
    }
    {
        let PlaylistTagCollection =
            None::<crate::api::music_api::mirror::PlaylistTagCollection>.unwrap();
        let _: String = PlaylistTagCollection.name;
        let _: Vec<crate::api::music_api::mirror::PlaylistTag> = PlaylistTagCollection.tags;
    }
    {
        let PlaylistUpdateSubscriptionResult =
            None::<crate::api::music_api::mirror::PlaylistUpdateSubscriptionResult>.unwrap();
        let _: Vec<(String, String)> = PlaylistUpdateSubscriptionResult.errors;
    }
    {
        let Quality = None::<crate::api::music_api::mirror::Quality>.unwrap();
        let _: String = Quality.summary;
        let _: Option<String> = Quality.bitrate;
        let _: Option<String> = Quality.format;
        let _: Option<String> = Quality.size;
    }
    {
        let ServerMusicChartCollection =
            None::<crate::api::music_api::mirror::ServerMusicChartCollection>.unwrap();
        let _: crate::api::music_api::mirror::MusicServer = ServerMusicChartCollection.server;
        let _: Vec<crate::api::music_api::mirror::MusicChartCollection> =
            ServerMusicChartCollection.collections;
    }
    {
        let ServerPlaylistTagCollection =
            None::<crate::api::music_api::mirror::ServerPlaylistTagCollection>.unwrap();
        let _: crate::api::music_api::mirror::MusicServer = ServerPlaylistTagCollection.server;
        let _: Vec<crate::api::music_api::mirror::PlaylistTagCollection> =
            ServerPlaylistTagCollection.collections;
    }
};

// Section: related_funcs

flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MusicDataJsonWrapper>
);

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for MusicDataJsonWrapper {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MusicDataJsonWrapper>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for std::collections::HashMap<String, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, String)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MusicDataJsonWrapper>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::music_api::mirror::Artist {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_id = <Option<String>>::sse_decode(deserializer);
        return crate::api::music_api::mirror::Artist {
            name: var_name,
            id: var_id,
        };
    }
}

impl SseDecode for crate::api::types::version::Asset {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_id = <u64>::sse_decode(deserializer);
        let mut var_nodeId = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_label = <Option<String>>::sse_decode(deserializer);
        let mut var_uploader = <crate::api::types::version::Author>::sse_decode(deserializer);
        let mut var_contentType = <String>::sse_decode(deserializer);
        let mut var_state = <String>::sse_decode(deserializer);
        let mut var_size = <u64>::sse_decode(deserializer);
        let mut var_downloadCount = <u64>::sse_decode(deserializer);
        let mut var_createdAt = <String>::sse_decode(deserializer);
        let mut var_updatedAt = <String>::sse_decode(deserializer);
        let mut var_browserDownloadUrl = <String>::sse_decode(deserializer);
        return crate::api::types::version::Asset {
            url: var_url,
            id: var_id,
            node_id: var_nodeId,
            name: var_name,
            label: var_label,
            uploader: var_uploader,
            content_type: var_contentType,
            state: var_state,
            size: var_size,
            download_count: var_downloadCount,
            created_at: var_createdAt,
            updated_at: var_updatedAt,
            browser_download_url: var_browserDownloadUrl,
        };
    }
}

impl SseDecode for crate::api::types::version::Author {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_login = <String>::sse_decode(deserializer);
        let mut var_id = <u64>::sse_decode(deserializer);
        let mut var_nodeId = <String>::sse_decode(deserializer);
        let mut var_avatarUrl = <String>::sse_decode(deserializer);
        let mut var_gravatarId = <String>::sse_decode(deserializer);
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_htmlUrl = <String>::sse_decode(deserializer);
        let mut var_followersUrl = <String>::sse_decode(deserializer);
        let mut var_followingUrl = <String>::sse_decode(deserializer);
        let mut var_gistsUrl = <String>::sse_decode(deserializer);
        let mut var_starredUrl = <String>::sse_decode(deserializer);
        let mut var_subscriptionsUrl = <String>::sse_decode(deserializer);
        let mut var_organizationsUrl = <String>::sse_decode(deserializer);
        let mut var_reposUrl = <String>::sse_decode(deserializer);
        let mut var_eventsUrl = <String>::sse_decode(deserializer);
        let mut var_receivedEventsUrl = <String>::sse_decode(deserializer);
        let mut var_type = <String>::sse_decode(deserializer);
        let mut var_siteAdmin = <bool>::sse_decode(deserializer);
        return crate::api::types::version::Author {
            login: var_login,
            id: var_id,
            node_id: var_nodeId,
            avatar_url: var_avatarUrl,
            gravatar_id: var_gravatarId,
            url: var_url,
            html_url: var_htmlUrl,
            followers_url: var_followersUrl,
            following_url: var_followingUrl,
            gists_url: var_gistsUrl,
            starred_url: var_starredUrl,
            subscriptions_url: var_subscriptionsUrl,
            organizations_url: var_organizationsUrl,
            repos_url: var_reposUrl,
            events_url: var_eventsUrl,
            received_events_url: var_receivedEventsUrl,
            r#type: var_type,
            site_admin: var_siteAdmin,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::types::config::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_userAgreement = <bool>::sse_decode(deserializer);
        let mut var_qualityConfig =
            <crate::api::types::config::QualityConfig>::sse_decode(deserializer);
        let mut var_externalApi =
            <Option<crate::api::types::external_api::ExternalApiConfig>>::sse_decode(deserializer);
        let mut var_updateConfig =
            <crate::api::types::config::UpdateConfig>::sse_decode(deserializer);
        let mut var_storageConfig =
            <crate::api::types::config::StorageConfig>::sse_decode(deserializer);
        let mut var_windowConfig =
            <Option<crate::api::types::config::WindowConfig>>::sse_decode(deserializer);
        return crate::api::types::config::Config {
            user_agreement: var_userAgreement,
            quality_config: var_qualityConfig,
            external_api: var_externalApi,
            update_config: var_updateConfig,
            storage_config: var_storageConfig,
            window_config: var_windowConfig,
        };
    }
}

impl SseDecode for crate::api::types::external_api::ExternalApiConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_filePath = <String>::sse_decode(deserializer);
        let mut var_url = <Option<String>>::sse_decode(deserializer);
        let mut var_lastHash = <Option<String>>::sse_decode(deserializer);
        return crate::api::types::external_api::ExternalApiConfig {
            file_path: var_filePath,
            url: var_url,
            last_hash: var_lastHash,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for Vec<crate::api::music_api::mirror::Artist> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::music_api::mirror::Artist>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::version::Asset> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::version::Asset>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::music_api::mirror::Music> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::music_api::mirror::Music>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::music_api::mirror::MusicAggregator> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::music_api::mirror::MusicAggregator>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::music_api::mirror::MusicChart> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::music_api::mirror::MusicChart>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::music_api::mirror::MusicChartCollection> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::api::music_api::mirror::MusicChartCollection>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::music_api::mirror::MusicServer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::music_api::mirror::MusicServer>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::music_api::mirror::PlayListSubscription> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::api::music_api::mirror::PlayListSubscription>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::music_api::mirror::Playlist> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::music_api::mirror::Playlist>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::music_api::mirror::PlaylistCollection> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::api::music_api::mirror::PlaylistCollection>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::music_api::mirror::PlaylistTag> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::music_api::mirror::PlaylistTag>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::music_api::mirror::PlaylistTagCollection> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::api::music_api::mirror::PlaylistTagCollection>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::music_api::mirror::Quality> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::music_api::mirror::Quality>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::music_api::mirror::ServerMusicChartCollection> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::api::music_api::mirror::ServerMusicChartCollection>::sse_decode(
                    deserializer,
                ),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::music_api::mirror::ServerPlaylistTagCollection> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::api::music_api::mirror::ServerPlaylistTagCollection>::sse_decode(
                    deserializer,
                ),
            );
        }
        return ans_;
    }
}

impl SseDecode for crate::api::log::LogLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::log::LogLevel::Debug,
            1 => crate::api::log::LogLevel::Info,
            2 => crate::api::log::LogLevel::Warn,
            3 => crate::api::log::LogLevel::Error,
            _ => unreachable!("Invalid variant for LogLevel: {}", inner),
        };
    }
}

impl SseDecode for crate::api::log::Logger {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::api::log::Logger {};
    }
}

impl SseDecode for crate::api::music_api::mirror::Music {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_fromDb = <bool>::sse_decode(deserializer);
        let mut var_server = <crate::api::music_api::mirror::MusicServer>::sse_decode(deserializer);
        let mut var_identity = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_duration = <Option<i64>>::sse_decode(deserializer);
        let mut var_artists =
            <Vec<crate::api::music_api::mirror::Artist>>::sse_decode(deserializer);
        let mut var_album = <Option<String>>::sse_decode(deserializer);
        let mut var_albumId = <Option<String>>::sse_decode(deserializer);
        let mut var_qualities =
            <Vec<crate::api::music_api::mirror::Quality>>::sse_decode(deserializer);
        let mut var_cover = <Option<String>>::sse_decode(deserializer);
        return crate::api::music_api::mirror::Music {
            from_db: var_fromDb,
            server: var_server,
            identity: var_identity,
            name: var_name,
            duration: var_duration,
            artists: var_artists,
            album: var_album,
            album_id: var_albumId,
            qualities: var_qualities,
            cover: var_cover,
        };
    }
}

impl SseDecode for crate::api::music_api::mirror::MusicAggregator {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_artist = <String>::sse_decode(deserializer);
        let mut var_fromDb = <bool>::sse_decode(deserializer);
        let mut var_order = <Option<i64>>::sse_decode(deserializer);
        let mut var_musics = <Vec<crate::api::music_api::mirror::Music>>::sse_decode(deserializer);
        let mut var_defaultServer =
            <crate::api::music_api::mirror::MusicServer>::sse_decode(deserializer);
        return crate::api::music_api::mirror::MusicAggregator {
            name: var_name,
            artist: var_artist,
            from_db: var_fromDb,
            order: var_order,
            musics: var_musics,
            default_server: var_defaultServer,
        };
    }
}

impl SseDecode for crate::api::music_api::mirror::MusicChart {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_summary = <Option<String>>::sse_decode(deserializer);
        let mut var_cover = <Option<String>>::sse_decode(deserializer);
        let mut var_id = <String>::sse_decode(deserializer);
        return crate::api::music_api::mirror::MusicChart {
            name: var_name,
            summary: var_summary,
            cover: var_cover,
            id: var_id,
        };
    }
}

impl SseDecode for crate::api::music_api::mirror::MusicChartCollection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_summary = <Option<String>>::sse_decode(deserializer);
        let mut var_charts =
            <Vec<crate::api::music_api::mirror::MusicChart>>::sse_decode(deserializer);
        return crate::api::music_api::mirror::MusicChartCollection {
            name: var_name,
            summary: var_summary,
            charts: var_charts,
        };
    }
}

impl SseDecode for crate::api::music_api::mirror::MusicDataType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::music_api::mirror::MusicDataType::Database,
            1 => crate::api::music_api::mirror::MusicDataType::Playlists,
            2 => crate::api::music_api::mirror::MusicDataType::MusicAggregators,
            _ => unreachable!("Invalid variant for MusicDataType: {}", inner),
        };
    }
}

impl SseDecode for crate::api::music_api::mirror::MusicServer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::music_api::mirror::MusicServer::Kuwo,
            1 => crate::api::music_api::mirror::MusicServer::Netease,
            _ => unreachable!("Invalid variant for MusicServer: {}", inner),
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::external_api::ExternalApiConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::api::types::external_api::ExternalApiConfig>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::music_api::mirror::MusicServer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::music_api::mirror::MusicServer>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::playinfo::PlayInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::playinfo::PlayInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::music_api::mirror::Playlist> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::music_api::mirror::Playlist>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::version::Release> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::version::Release>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::config::WindowConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::config::WindowConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::api::music_api::mirror::PlayListSubscription>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <Vec<crate::api::music_api::mirror::PlayListSubscription>>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::types::playinfo::PlayInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_uri = <String>::sse_decode(deserializer);
        let mut var_quality = <crate::api::music_api::mirror::Quality>::sse_decode(deserializer);
        return crate::api::types::playinfo::PlayInfo {
            uri: var_uri,
            quality: var_quality,
        };
    }
}

impl SseDecode for crate::api::music_api::mirror::PlayListSubscription {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_share = <String>::sse_decode(deserializer);
        return crate::api::music_api::mirror::PlayListSubscription {
            name: var_name,
            share: var_share,
        };
    }
}

impl SseDecode for crate::api::music_api::mirror::Playlist {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_fromDb = <bool>::sse_decode(deserializer);
        let mut var_server =
            <Option<crate::api::music_api::mirror::MusicServer>>::sse_decode(deserializer);
        let mut var_typeField =
            <crate::api::music_api::mirror::PlaylistType>::sse_decode(deserializer);
        let mut var_identity = <String>::sse_decode(deserializer);
        let mut var_collectionId = <Option<i64>>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_order = <Option<i64>>::sse_decode(deserializer);
        let mut var_summary = <Option<String>>::sse_decode(deserializer);
        let mut var_cover = <Option<String>>::sse_decode(deserializer);
        let mut var_creator = <Option<String>>::sse_decode(deserializer);
        let mut var_creatorId = <Option<String>>::sse_decode(deserializer);
        let mut var_playTime = <Option<i64>>::sse_decode(deserializer);
        let mut var_musicNum = <Option<i64>>::sse_decode(deserializer);
        let mut var_subscription =
            <Option<Vec<crate::api::music_api::mirror::PlayListSubscription>>>::sse_decode(
                deserializer,
            );
        return crate::api::music_api::mirror::Playlist {
            from_db: var_fromDb,
            server: var_server,
            type_field: var_typeField,
            identity: var_identity,
            collection_id: var_collectionId,
            name: var_name,
            order: var_order,
            summary: var_summary,
            cover: var_cover,
            creator: var_creator,
            creator_id: var_creatorId,
            play_time: var_playTime,
            music_num: var_musicNum,
            subscription: var_subscription,
        };
    }
}

impl SseDecode for crate::api::music_api::mirror::PlaylistCollection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <i64>::sse_decode(deserializer);
        let mut var_order = <i64>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        return crate::api::music_api::mirror::PlaylistCollection {
            id: var_id,
            order: var_order,
            name: var_name,
        };
    }
}

impl SseDecode for crate::api::music_api::mirror::PlaylistTag {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_id = <String>::sse_decode(deserializer);
        return crate::api::music_api::mirror::PlaylistTag {
            name: var_name,
            id: var_id,
        };
    }
}

impl SseDecode for crate::api::music_api::mirror::PlaylistTagCollection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_tags =
            <Vec<crate::api::music_api::mirror::PlaylistTag>>::sse_decode(deserializer);
        return crate::api::music_api::mirror::PlaylistTagCollection {
            name: var_name,
            tags: var_tags,
        };
    }
}

impl SseDecode for crate::api::music_api::mirror::PlaylistType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::music_api::mirror::PlaylistType::UserPlaylist,
            1 => crate::api::music_api::mirror::PlaylistType::Album,
            _ => unreachable!("Invalid variant for PlaylistType: {}", inner),
        };
    }
}

impl SseDecode for crate::api::music_api::mirror::PlaylistUpdateSubscriptionResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_errors = <Vec<(String, String)>>::sse_decode(deserializer);
        return crate::api::music_api::mirror::PlaylistUpdateSubscriptionResult {
            errors: var_errors,
        };
    }
}

impl SseDecode for crate::api::music_api::mirror::Quality {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_summary = <String>::sse_decode(deserializer);
        let mut var_bitrate = <Option<String>>::sse_decode(deserializer);
        let mut var_format = <Option<String>>::sse_decode(deserializer);
        let mut var_size = <Option<String>>::sse_decode(deserializer);
        return crate::api::music_api::mirror::Quality {
            summary: var_summary,
            bitrate: var_bitrate,
            format: var_format,
            size: var_size,
        };
    }
}

impl SseDecode for crate::api::types::config::QualityConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_wifiAutoQuality =
            <crate::api::types::config::QualityOption>::sse_decode(deserializer);
        let mut var_mobileAutoQuality =
            <crate::api::types::config::QualityOption>::sse_decode(deserializer);
        return crate::api::types::config::QualityConfig {
            wifi_auto_quality: var_wifiAutoQuality,
            mobile_auto_quality: var_mobileAutoQuality,
        };
    }
}

impl SseDecode for crate::api::types::config::QualityOption {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::config::QualityOption::Highest,
            1 => crate::api::types::config::QualityOption::High,
            2 => crate::api::types::config::QualityOption::Medium,
            3 => crate::api::types::config::QualityOption::Low,
            _ => unreachable!("Invalid variant for QualityOption: {}", inner),
        };
    }
}

impl SseDecode
    for (
        Option<crate::api::types::playinfo::PlayInfo>,
        Option<String>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 =
            <Option<crate::api::types::playinfo::PlayInfo>>::sse_decode(deserializer);
        let mut var_field1 = <Option<String>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode
    for (
        Option<crate::api::music_api::mirror::Playlist>,
        Vec<crate::api::music_api::mirror::MusicAggregator>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 =
            <Option<crate::api::music_api::mirror::Playlist>>::sse_decode(deserializer);
        let mut var_field1 =
            <Vec<crate::api::music_api::mirror::MusicAggregator>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::api::types::version::Release {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_assetsUrl = <String>::sse_decode(deserializer);
        let mut var_uploadUrl = <String>::sse_decode(deserializer);
        let mut var_htmlUrl = <String>::sse_decode(deserializer);
        let mut var_id = <u64>::sse_decode(deserializer);
        let mut var_author = <crate::api::types::version::Author>::sse_decode(deserializer);
        let mut var_nodeId = <String>::sse_decode(deserializer);
        let mut var_tagName = <String>::sse_decode(deserializer);
        let mut var_targetCommitish = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_draft = <bool>::sse_decode(deserializer);
        let mut var_prerelease = <bool>::sse_decode(deserializer);
        let mut var_createdAt = <String>::sse_decode(deserializer);
        let mut var_publishedAt = <String>::sse_decode(deserializer);
        let mut var_assets = <Vec<crate::api::types::version::Asset>>::sse_decode(deserializer);
        let mut var_tarballUrl = <String>::sse_decode(deserializer);
        let mut var_zipballUrl = <String>::sse_decode(deserializer);
        let mut var_body = <String>::sse_decode(deserializer);
        return crate::api::types::version::Release {
            url: var_url,
            assets_url: var_assetsUrl,
            upload_url: var_uploadUrl,
            html_url: var_htmlUrl,
            id: var_id,
            author: var_author,
            node_id: var_nodeId,
            tag_name: var_tagName,
            target_commitish: var_targetCommitish,
            name: var_name,
            draft: var_draft,
            prerelease: var_prerelease,
            created_at: var_createdAt,
            published_at: var_publishedAt,
            assets: var_assets,
            tarball_url: var_tarballUrl,
            zipball_url: var_zipballUrl,
            body: var_body,
        };
    }
}

impl SseDecode for crate::api::music_api::mirror::ServerMusicChartCollection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_server = <crate::api::music_api::mirror::MusicServer>::sse_decode(deserializer);
        let mut var_collections =
            <Vec<crate::api::music_api::mirror::MusicChartCollection>>::sse_decode(deserializer);
        return crate::api::music_api::mirror::ServerMusicChartCollection {
            server: var_server,
            collections: var_collections,
        };
    }
}

impl SseDecode for crate::api::music_api::mirror::ServerPlaylistTagCollection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_server = <crate::api::music_api::mirror::MusicServer>::sse_decode(deserializer);
        let mut var_collections =
            <Vec<crate::api::music_api::mirror::PlaylistTagCollection>>::sse_decode(deserializer);
        return crate::api::music_api::mirror::ServerPlaylistTagCollection {
            server: var_server,
            collections: var_collections,
        };
    }
}

impl SseDecode for crate::api::types::config::StorageConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_saveCover = <bool>::sse_decode(deserializer);
        let mut var_customCacheRoot = <Option<String>>::sse_decode(deserializer);
        let mut var_customDb = <Option<String>>::sse_decode(deserializer);
        return crate::api::types::config::StorageConfig {
            save_cover: var_saveCover,
            custom_cache_root: var_customCacheRoot,
            custom_db: var_customDb,
        };
    }
}

impl SseDecode for crate::api::music_api::mirror::TagPlaylistOrder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::music_api::mirror::TagPlaylistOrder::Hot,
            1 => crate::api::music_api::mirror::TagPlaylistOrder::New,
            _ => unreachable!("Invalid variant for TagPlaylistOrder: {}", inner),
        };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for crate::api::types::config::UpdateConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_versionAutoUpdate = <bool>::sse_decode(deserializer);
        let mut var_externalApiAutoUpdate = <bool>::sse_decode(deserializer);
        return crate::api::types::config::UpdateConfig {
            version_auto_update: var_versionAutoUpdate,
            external_api_auto_update: var_externalApiAutoUpdate,
        };
    }
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::api::types::config::WindowConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_width = <i32>::sse_decode(deserializer);
        let mut var_height = <i32>::sse_decode(deserializer);
        let mut var_minWidth = <i32>::sse_decode(deserializer);
        let mut var_minHeight = <i32>::sse_decode(deserializer);
        let mut var_fullscreen = <bool>::sse_decode(deserializer);
        return crate::api::types::config::WindowConfig {
            width: var_width,
            height: var_height,
            min_width: var_minWidth,
            min_height: var_minHeight,
            fullscreen: var_fullscreen,
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
                        1 => wire__crate__api__music_api__wrapper__MusicDataJsonWrapper_apply_to_db_impl(port, ptr, rust_vec_len, data_len),
2 => wire__crate__api__music_api__wrapper__MusicDataJsonWrapper_from_database_impl(port, ptr, rust_vec_len, data_len),
3 => wire__crate__api__music_api__wrapper__MusicDataJsonWrapper_from_json_impl(port, ptr, rust_vec_len, data_len),
4 => wire__crate__api__music_api__wrapper__MusicDataJsonWrapper_from_music_aggregators_impl(port, ptr, rust_vec_len, data_len),
5 => wire__crate__api__music_api__wrapper__MusicDataJsonWrapper_from_playlists_impl(port, ptr, rust_vec_len, data_len),
6 => wire__crate__api__music_api__wrapper__MusicDataJsonWrapper_get_type_impl(port, ptr, rust_vec_len, data_len),
7 => wire__crate__api__music_api__wrapper__MusicDataJsonWrapper_load_from_impl(port, ptr, rust_vec_len, data_len),
8 => wire__crate__api__music_api__wrapper__MusicDataJsonWrapper_save_to_impl(port, ptr, rust_vec_len, data_len),
9 => wire__crate__api__music_api__wrapper__MusicDataJsonWrapper_to_json_impl(port, ptr, rust_vec_len, data_len),
10 => wire__crate__api__cache__file_cache__cache_file_from_content_impl(port, ptr, rust_vec_len, data_len),
11 => wire__crate__api__cache__file_cache__cache_file_from_uri_impl(port, ptr, rust_vec_len, data_len),
12 => wire__crate__api__cache__music_cache__cache_music_impl(port, ptr, rust_vec_len, data_len),
13 => wire__crate__api__types__version__check_update_impl(port, ptr, rust_vec_len, data_len),
14 => wire__crate__api__music_api__fns__clear_db_impl(port, ptr, rust_vec_len, data_len),
15 => wire__crate__api__music_api__fns__close_db_impl(port, ptr, rust_vec_len, data_len),
16 => wire__crate__api__types__config__config_default_impl(port, ptr, rust_vec_len, data_len),
19 => wire__crate__api__types__config__config_load_impl(port, ptr, rust_vec_len, data_len),
20 => wire__crate__api__types__config__config_save_impl(port, ptr, rust_vec_len, data_len),
21 => wire__crate__api__cache__cache_util__delete_cache_data_impl(port, ptr, rust_vec_len, data_len),
22 => wire__crate__api__cache__file_cache__delete_cache_file_with_uri_impl(port, ptr, rust_vec_len, data_len),
23 => wire__crate__api__cache__music_cache__delete_music_cache_impl(port, ptr, rust_vec_len, data_len),
24 => wire__crate__api__types__external_api__external_api_config_fetch_update_impl(port, ptr, rust_vec_len, data_len),
25 => wire__crate__api__types__external_api__external_api_config_from_path_impl(port, ptr, rust_vec_len, data_len),
26 => wire__crate__api__types__external_api__external_api_config_from_url_impl(port, ptr, rust_vec_len, data_len),
27 => wire__crate__api__cache__file_cache__gen_hash_impl(port, ptr, rust_vec_len, data_len),
28 => wire__crate__api__utils__path_util__get_apprhyme_dir_impl(port, ptr, rust_vec_len, data_len),
30 => wire__crate__api__cache__music_cache__get_cache_music_impl(port, ptr, rust_vec_len, data_len),
31 => wire__crate__api__utils__path_util__get_log_dir_impl(port, ptr, rust_vec_len, data_len),
32 => wire__crate__api__types__version__get_release_impl(port, ptr, rust_vec_len, data_len),
33 => wire__crate__api__cache__music_cache__has_cache_music_impl(port, ptr, rust_vec_len, data_len),
34 => wire__crate__api__init__init_impl(port, ptr, rust_vec_len, data_len),
35 => wire__crate__api__log__init_impl(port, ptr, rust_vec_len, data_len),
36 => wire__crate__api__init__init_backend_impl(port, ptr, rust_vec_len, data_len),
37 => wire__crate__api__log__logger_debug_impl(port, ptr, rust_vec_len, data_len),
38 => wire__crate__api__log__logger_error_impl(port, ptr, rust_vec_len, data_len),
39 => wire__crate__api__log__logger_info_impl(port, ptr, rust_vec_len, data_len),
40 => wire__crate__api__log__logger_new_impl(port, ptr, rust_vec_len, data_len),
41 => wire__crate__api__log__logger_warn_impl(port, ptr, rust_vec_len, data_len),
42 => wire__crate__api__cache__cache_util__move_cache_data_impl(port, ptr, rust_vec_len, data_len),
43 => wire__crate__api__music_api__mirror__music_aggregator_change_default_server_in_db_impl(port, ptr, rust_vec_len, data_len),
44 => wire__crate__api__music_api__mirror__music_aggregator_clear_unused_impl(port, ptr, rust_vec_len, data_len),
45 => wire__crate__api__music_api__mirror__music_aggregator_del_from_db_impl(port, ptr, rust_vec_len, data_len),
46 => wire__crate__api__music_api__mirror__music_aggregator_fetch_artist_music_aggregators_impl(port, ptr, rust_vec_len, data_len),
47 => wire__crate__api__music_api__mirror__music_aggregator_fetch_server_online_impl(port, ptr, rust_vec_len, data_len),
48 => wire__crate__api__music_api__mirror__music_aggregator_from_music_impl(port, ptr, rust_vec_len, data_len),
50 => wire__crate__api__music_api__mirror__music_aggregator_save_to_db_impl(port, ptr, rust_vec_len, data_len),
51 => wire__crate__api__music_api__mirror__music_aggregator_search_online_impl(port, ptr, rust_vec_len, data_len),
52 => wire__crate__api__music_api__mirror__music_aggregator_update_order_to_db_impl(port, ptr, rust_vec_len, data_len),
53 => wire__crate__api__music_api__mirror__music_get_album_impl(port, ptr, rust_vec_len, data_len),
55 => wire__crate__api__music_api__mirror__music_get_lyric_impl(port, ptr, rust_vec_len, data_len),
56 => wire__crate__api__music_api__mirror__music_insert_to_db_impl(port, ptr, rust_vec_len, data_len),
57 => wire__crate__api__music_api__mirror__music_search_online_impl(port, ptr, rust_vec_len, data_len),
61 => wire__crate__api__music_api__plugin_fn__music_to_json_impl(port, ptr, rust_vec_len, data_len),
62 => wire__crate__api__music_api__mirror__music_update_to_db_impl(port, ptr, rust_vec_len, data_len),
63 => wire__crate__api__music_api__mirror__playlist_add_aggs_to_db_impl(port, ptr, rust_vec_len, data_len),
64 => wire__crate__api__music_api__mirror__playlist_collection_delete_from_db_impl(port, ptr, rust_vec_len, data_len),
65 => wire__crate__api__music_api__mirror__playlist_collection_find_in_db_impl(port, ptr, rust_vec_len, data_len),
66 => wire__crate__api__music_api__mirror__playlist_collection_get_form_db_impl(port, ptr, rust_vec_len, data_len),
67 => wire__crate__api__music_api__mirror__playlist_collection_get_playlists_from_db_impl(port, ptr, rust_vec_len, data_len),
68 => wire__crate__api__music_api__mirror__playlist_collection_insert_to_db_impl(port, ptr, rust_vec_len, data_len),
69 => wire__crate__api__music_api__mirror__playlist_collection_new_impl(port, ptr, rust_vec_len, data_len),
70 => wire__crate__api__music_api__mirror__playlist_collection_update_to_db_impl(port, ptr, rust_vec_len, data_len),
71 => wire__crate__api__music_api__mirror__playlist_del_from_db_impl(port, ptr, rust_vec_len, data_len),
72 => wire__crate__api__music_api__mirror__playlist_del_music_agg_impl(port, ptr, rust_vec_len, data_len),
73 => wire__crate__api__music_api__mirror__playlist_fetch_artist_albums_impl(port, ptr, rust_vec_len, data_len),
74 => wire__crate__api__music_api__mirror__playlist_fetch_musics_online_impl(port, ptr, rust_vec_len, data_len),
75 => wire__crate__api__music_api__mirror__playlist_find_in_db_impl(port, ptr, rust_vec_len, data_len),
77 => wire__crate__api__music_api__mirror__playlist_get_from_db_impl(port, ptr, rust_vec_len, data_len),
78 => wire__crate__api__music_api__mirror__playlist_get_from_share_impl(port, ptr, rust_vec_len, data_len),
79 => wire__crate__api__music_api__mirror__playlist_get_musics_from_db_impl(port, ptr, rust_vec_len, data_len),
80 => wire__crate__api__music_api__mirror__playlist_insert_to_db_impl(port, ptr, rust_vec_len, data_len),
81 => wire__crate__api__music_api__mirror__playlist_new_impl(port, ptr, rust_vec_len, data_len),
82 => wire__crate__api__music_api__mirror__playlist_search_online_impl(port, ptr, rust_vec_len, data_len),
83 => wire__crate__api__music_api__mirror__playlist_update_subscription_impl(port, ptr, rust_vec_len, data_len),
84 => wire__crate__api__music_api__mirror__playlist_update_to_db_impl(port, ptr, rust_vec_len, data_len),
85 => wire__crate__api__types__config__quality_config_default_impl(port, ptr, rust_vec_len, data_len),
86 => wire__crate__api__utils__crypto__rc4_decrypt_from_base64_impl(port, ptr, rust_vec_len, data_len),
87 => wire__crate__api__utils__crypto__rc4_encrypt_to_base64_impl(port, ptr, rust_vec_len, data_len),
88 => wire__crate__api__music_api__fns__reinit_db_impl(port, ptr, rust_vec_len, data_len),
89 => wire__crate__api__log__save_log_impl(port, ptr, rust_vec_len, data_len),
90 => wire__crate__api__utils__http_helper__send_request_impl(port, ptr, rust_vec_len, data_len),
91 => wire__crate__api__music_api__mirror__server_music_chart_collection_get_music_chart_collection_impl(port, ptr, rust_vec_len, data_len),
92 => wire__crate__api__music_api__mirror__server_music_chart_collection_get_musics_from_chart_impl(port, ptr, rust_vec_len, data_len),
93 => wire__crate__api__music_api__mirror__server_playlist_tag_collection_get_playlist_tags_impl(port, ptr, rust_vec_len, data_len),
94 => wire__crate__api__music_api__mirror__server_playlist_tag_collection_get_playlists_from_tag_impl(port, ptr, rust_vec_len, data_len),
95 => wire__crate__api__music_api__fns__set_db_impl(port, ptr, rust_vec_len, data_len),
96 => wire__crate__api__types__config__storage_config_default_impl(port, ptr, rust_vec_len, data_len),
97 => wire__crate__api__types__config__update_config_default_impl(port, ptr, rust_vec_len, data_len),
98 => wire__crate__api__utils__path_util__url_encode_special_chars_impl(port, ptr, rust_vec_len, data_len),
99 => wire__crate__api__utils__database__verify_sqlite_url_impl(port, ptr, rust_vec_len, data_len),
                        _ => unreachable!(),
                    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        17 => wire__crate__api__types__config__config_get_sql_url_impl(ptr, rust_vec_len, data_len),
        18 => wire__crate__api__types__config__config_get_storage_folder_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        29 => wire__crate__api__cache__file_cache__get_cache_file_from_uri_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        49 => wire__crate__api__music_api__mirror__music_aggregator_identity_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        54 => {
            wire__crate__api__music_api__mirror__music_get_cover_impl(ptr, rust_vec_len, data_len)
        }
        58 => {
            wire__crate__api__music_api__mirror__music_server_all_impl(ptr, rust_vec_len, data_len)
        }
        59 => wire__crate__api__music_api__mirror__music_server_length_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        60 => wire__crate__api__music_api__mirror__music_server_to_string_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        76 => wire__crate__api__music_api__mirror__playlist_get_cover_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        100 => {
            wire__crate__api__types__config__window_config_default_impl(ptr, rust_vec_len, data_len)
        }
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MusicDataJsonWrapper> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<MusicDataJsonWrapper>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MusicDataJsonWrapper>> for MusicDataJsonWrapper {
    fn into_into_dart(self) -> FrbWrapper<MusicDataJsonWrapper> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::music_api::mirror::Artist> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.name.into_into_dart().into_dart(),
            self.0.id.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::music_api::mirror::Artist>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::music_api::mirror::Artist>>
    for crate::api::music_api::mirror::Artist
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::music_api::mirror::Artist> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::version::Asset {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.url.into_into_dart().into_dart(),
            self.id.into_into_dart().into_dart(),
            self.node_id.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.label.into_into_dart().into_dart(),
            self.uploader.into_into_dart().into_dart(),
            self.content_type.into_into_dart().into_dart(),
            self.state.into_into_dart().into_dart(),
            self.size.into_into_dart().into_dart(),
            self.download_count.into_into_dart().into_dart(),
            self.created_at.into_into_dart().into_dart(),
            self.updated_at.into_into_dart().into_dart(),
            self.browser_download_url.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::version::Asset
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::version::Asset>
    for crate::api::types::version::Asset
{
    fn into_into_dart(self) -> crate::api::types::version::Asset {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::version::Author {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.login.into_into_dart().into_dart(),
            self.id.into_into_dart().into_dart(),
            self.node_id.into_into_dart().into_dart(),
            self.avatar_url.into_into_dart().into_dart(),
            self.gravatar_id.into_into_dart().into_dart(),
            self.url.into_into_dart().into_dart(),
            self.html_url.into_into_dart().into_dart(),
            self.followers_url.into_into_dart().into_dart(),
            self.following_url.into_into_dart().into_dart(),
            self.gists_url.into_into_dart().into_dart(),
            self.starred_url.into_into_dart().into_dart(),
            self.subscriptions_url.into_into_dart().into_dart(),
            self.organizations_url.into_into_dart().into_dart(),
            self.repos_url.into_into_dart().into_dart(),
            self.events_url.into_into_dart().into_dart(),
            self.received_events_url.into_into_dart().into_dart(),
            self.r#type.into_into_dart().into_dart(),
            self.site_admin.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::version::Author
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::version::Author>
    for crate::api::types::version::Author
{
    fn into_into_dart(self) -> crate::api::types::version::Author {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::config::Config {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.user_agreement.into_into_dart().into_dart(),
            self.quality_config.into_into_dart().into_dart(),
            self.external_api.into_into_dart().into_dart(),
            self.update_config.into_into_dart().into_dart(),
            self.storage_config.into_into_dart().into_dart(),
            self.window_config.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::config::Config
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::config::Config>
    for crate::api::types::config::Config
{
    fn into_into_dart(self) -> crate::api::types::config::Config {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::external_api::ExternalApiConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.file_path.into_into_dart().into_dart(),
            self.url.into_into_dart().into_dart(),
            self.last_hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::external_api::ExternalApiConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::external_api::ExternalApiConfig>
    for crate::api::types::external_api::ExternalApiConfig
{
    fn into_into_dart(self) -> crate::api::types::external_api::ExternalApiConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::log::LogLevel {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Debug => 0.into_dart(),
            Self::Info => 1.into_dart(),
            Self::Warn => 2.into_dart(),
            Self::Error => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::log::LogLevel {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::log::LogLevel> for crate::api::log::LogLevel {
    fn into_into_dart(self) -> crate::api::log::LogLevel {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::log::Logger {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::log::Logger {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::log::Logger> for crate::api::log::Logger {
    fn into_into_dart(self) -> crate::api::log::Logger {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::music_api::mirror::Music> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.from_db.into_into_dart().into_dart(),
            self.0.server.into_into_dart().into_dart(),
            self.0.identity.into_into_dart().into_dart(),
            self.0.name.into_into_dart().into_dart(),
            self.0.duration.into_into_dart().into_dart(),
            self.0.artists.into_into_dart().into_dart(),
            self.0.album.into_into_dart().into_dart(),
            self.0.album_id.into_into_dart().into_dart(),
            self.0.qualities.into_into_dart().into_dart(),
            self.0.cover.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::music_api::mirror::Music>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::music_api::mirror::Music>>
    for crate::api::music_api::mirror::Music
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::music_api::mirror::Music> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::music_api::mirror::MusicAggregator> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.name.into_into_dart().into_dart(),
            self.0.artist.into_into_dart().into_dart(),
            self.0.from_db.into_into_dart().into_dart(),
            self.0.order.into_into_dart().into_dart(),
            self.0.musics.into_into_dart().into_dart(),
            self.0.default_server.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::music_api::mirror::MusicAggregator>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::music_api::mirror::MusicAggregator>>
    for crate::api::music_api::mirror::MusicAggregator
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::music_api::mirror::MusicAggregator> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::music_api::mirror::MusicChart> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.name.into_into_dart().into_dart(),
            self.0.summary.into_into_dart().into_dart(),
            self.0.cover.into_into_dart().into_dart(),
            self.0.id.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::music_api::mirror::MusicChart>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::music_api::mirror::MusicChart>>
    for crate::api::music_api::mirror::MusicChart
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::music_api::mirror::MusicChart> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::api::music_api::mirror::MusicChartCollection>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.name.into_into_dart().into_dart(),
            self.0.summary.into_into_dart().into_dart(),
            self.0.charts.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::music_api::mirror::MusicChartCollection>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::api::music_api::mirror::MusicChartCollection>,
    > for crate::api::music_api::mirror::MusicChartCollection
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::music_api::mirror::MusicChartCollection> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::music_api::mirror::MusicDataType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::music_api::mirror::MusicDataType::Database => 0.into_dart(),
            crate::api::music_api::mirror::MusicDataType::Playlists => 1.into_dart(),
            crate::api::music_api::mirror::MusicDataType::MusicAggregators => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::music_api::mirror::MusicDataType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::music_api::mirror::MusicDataType>>
    for crate::api::music_api::mirror::MusicDataType
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::music_api::mirror::MusicDataType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::music_api::mirror::MusicServer> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::music_api::mirror::MusicServer::Kuwo => 0.into_dart(),
            crate::api::music_api::mirror::MusicServer::Netease => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::music_api::mirror::MusicServer>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::music_api::mirror::MusicServer>>
    for crate::api::music_api::mirror::MusicServer
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::music_api::mirror::MusicServer> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::playinfo::PlayInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.uri.into_into_dart().into_dart(),
            self.quality.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::playinfo::PlayInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::playinfo::PlayInfo>
    for crate::api::types::playinfo::PlayInfo
{
    fn into_into_dart(self) -> crate::api::types::playinfo::PlayInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::api::music_api::mirror::PlayListSubscription>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.name.into_into_dart().into_dart(),
            self.0.share.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::music_api::mirror::PlayListSubscription>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::api::music_api::mirror::PlayListSubscription>,
    > for crate::api::music_api::mirror::PlayListSubscription
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::music_api::mirror::PlayListSubscription> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::music_api::mirror::Playlist> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.from_db.into_into_dart().into_dart(),
            self.0.server.into_into_dart().into_dart(),
            self.0.type_field.into_into_dart().into_dart(),
            self.0.identity.into_into_dart().into_dart(),
            self.0.collection_id.into_into_dart().into_dart(),
            self.0.name.into_into_dart().into_dart(),
            self.0.order.into_into_dart().into_dart(),
            self.0.summary.into_into_dart().into_dart(),
            self.0.cover.into_into_dart().into_dart(),
            self.0.creator.into_into_dart().into_dart(),
            self.0.creator_id.into_into_dart().into_dart(),
            self.0.play_time.into_into_dart().into_dart(),
            self.0.music_num.into_into_dart().into_dart(),
            self.0.subscription.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::music_api::mirror::Playlist>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::music_api::mirror::Playlist>>
    for crate::api::music_api::mirror::Playlist
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::music_api::mirror::Playlist> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::api::music_api::mirror::PlaylistCollection>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.id.into_into_dart().into_dart(),
            self.0.order.into_into_dart().into_dart(),
            self.0.name.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::music_api::mirror::PlaylistCollection>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::music_api::mirror::PlaylistCollection>>
    for crate::api::music_api::mirror::PlaylistCollection
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::music_api::mirror::PlaylistCollection> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::music_api::mirror::PlaylistTag> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.name.into_into_dart().into_dart(),
            self.0.id.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::music_api::mirror::PlaylistTag>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::music_api::mirror::PlaylistTag>>
    for crate::api::music_api::mirror::PlaylistTag
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::music_api::mirror::PlaylistTag> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::api::music_api::mirror::PlaylistTagCollection>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.name.into_into_dart().into_dart(),
            self.0.tags.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::music_api::mirror::PlaylistTagCollection>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::api::music_api::mirror::PlaylistTagCollection>,
    > for crate::api::music_api::mirror::PlaylistTagCollection
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::music_api::mirror::PlaylistTagCollection> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::music_api::mirror::PlaylistType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::music_api::mirror::PlaylistType::UserPlaylist => 0.into_dart(),
            crate::api::music_api::mirror::PlaylistType::Album => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::music_api::mirror::PlaylistType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::music_api::mirror::PlaylistType>>
    for crate::api::music_api::mirror::PlaylistType
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::music_api::mirror::PlaylistType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::api::music_api::mirror::PlaylistUpdateSubscriptionResult>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.errors.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::music_api::mirror::PlaylistUpdateSubscriptionResult>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::api::music_api::mirror::PlaylistUpdateSubscriptionResult>,
    > for crate::api::music_api::mirror::PlaylistUpdateSubscriptionResult
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<crate::api::music_api::mirror::PlaylistUpdateSubscriptionResult> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::music_api::mirror::Quality> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.summary.into_into_dart().into_dart(),
            self.0.bitrate.into_into_dart().into_dart(),
            self.0.format.into_into_dart().into_dart(),
            self.0.size.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::music_api::mirror::Quality>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::music_api::mirror::Quality>>
    for crate::api::music_api::mirror::Quality
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::music_api::mirror::Quality> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::config::QualityConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.wifi_auto_quality.into_into_dart().into_dart(),
            self.mobile_auto_quality.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::config::QualityConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::config::QualityConfig>
    for crate::api::types::config::QualityConfig
{
    fn into_into_dart(self) -> crate::api::types::config::QualityConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::config::QualityOption {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Highest => 0.into_dart(),
            Self::High => 1.into_dart(),
            Self::Medium => 2.into_dart(),
            Self::Low => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::config::QualityOption
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::config::QualityOption>
    for crate::api::types::config::QualityOption
{
    fn into_into_dart(self) -> crate::api::types::config::QualityOption {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::version::Release {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.url.into_into_dart().into_dart(),
            self.assets_url.into_into_dart().into_dart(),
            self.upload_url.into_into_dart().into_dart(),
            self.html_url.into_into_dart().into_dart(),
            self.id.into_into_dart().into_dart(),
            self.author.into_into_dart().into_dart(),
            self.node_id.into_into_dart().into_dart(),
            self.tag_name.into_into_dart().into_dart(),
            self.target_commitish.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.draft.into_into_dart().into_dart(),
            self.prerelease.into_into_dart().into_dart(),
            self.created_at.into_into_dart().into_dart(),
            self.published_at.into_into_dart().into_dart(),
            self.assets.into_into_dart().into_dart(),
            self.tarball_url.into_into_dart().into_dart(),
            self.zipball_url.into_into_dart().into_dart(),
            self.body.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::version::Release
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::version::Release>
    for crate::api::types::version::Release
{
    fn into_into_dart(self) -> crate::api::types::version::Release {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::api::music_api::mirror::ServerMusicChartCollection>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.server.into_into_dart().into_dart(),
            self.0.collections.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::music_api::mirror::ServerMusicChartCollection>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::api::music_api::mirror::ServerMusicChartCollection>,
    > for crate::api::music_api::mirror::ServerMusicChartCollection
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<crate::api::music_api::mirror::ServerMusicChartCollection> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::api::music_api::mirror::ServerPlaylistTagCollection>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.server.into_into_dart().into_dart(),
            self.0.collections.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::music_api::mirror::ServerPlaylistTagCollection>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::api::music_api::mirror::ServerPlaylistTagCollection>,
    > for crate::api::music_api::mirror::ServerPlaylistTagCollection
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<crate::api::music_api::mirror::ServerPlaylistTagCollection> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::config::StorageConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.save_cover.into_into_dart().into_dart(),
            self.custom_cache_root.into_into_dart().into_dart(),
            self.custom_db.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::config::StorageConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::config::StorageConfig>
    for crate::api::types::config::StorageConfig
{
    fn into_into_dart(self) -> crate::api::types::config::StorageConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::music_api::mirror::TagPlaylistOrder> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::music_api::mirror::TagPlaylistOrder::Hot => 0.into_dart(),
            crate::api::music_api::mirror::TagPlaylistOrder::New => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::music_api::mirror::TagPlaylistOrder>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::music_api::mirror::TagPlaylistOrder>>
    for crate::api::music_api::mirror::TagPlaylistOrder
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::music_api::mirror::TagPlaylistOrder> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::config::UpdateConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.version_auto_update.into_into_dart().into_dart(),
            self.external_api_auto_update.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::config::UpdateConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::config::UpdateConfig>
    for crate::api::types::config::UpdateConfig
{
    fn into_into_dart(self) -> crate::api::types::config::UpdateConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::config::WindowConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.width.into_into_dart().into_dart(),
            self.height.into_into_dart().into_dart(),
            self.min_width.into_into_dart().into_dart(),
            self.min_height.into_into_dart().into_dart(),
            self.fullscreen.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::config::WindowConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::config::WindowConfig>
    for crate::api::types::config::WindowConfig
{
    fn into_into_dart(self) -> crate::api::types::config::WindowConfig {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for MusicDataJsonWrapper {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MusicDataJsonWrapper>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for std::collections::HashMap<String, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, String)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MusicDataJsonWrapper>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::music_api::mirror::Artist {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <Option<String>>::sse_encode(self.id, serializer);
    }
}

impl SseEncode for crate::api::types::version::Asset {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.url, serializer);
        <u64>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.node_id, serializer);
        <String>::sse_encode(self.name, serializer);
        <Option<String>>::sse_encode(self.label, serializer);
        <crate::api::types::version::Author>::sse_encode(self.uploader, serializer);
        <String>::sse_encode(self.content_type, serializer);
        <String>::sse_encode(self.state, serializer);
        <u64>::sse_encode(self.size, serializer);
        <u64>::sse_encode(self.download_count, serializer);
        <String>::sse_encode(self.created_at, serializer);
        <String>::sse_encode(self.updated_at, serializer);
        <String>::sse_encode(self.browser_download_url, serializer);
    }
}

impl SseEncode for crate::api::types::version::Author {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.login, serializer);
        <u64>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.node_id, serializer);
        <String>::sse_encode(self.avatar_url, serializer);
        <String>::sse_encode(self.gravatar_id, serializer);
        <String>::sse_encode(self.url, serializer);
        <String>::sse_encode(self.html_url, serializer);
        <String>::sse_encode(self.followers_url, serializer);
        <String>::sse_encode(self.following_url, serializer);
        <String>::sse_encode(self.gists_url, serializer);
        <String>::sse_encode(self.starred_url, serializer);
        <String>::sse_encode(self.subscriptions_url, serializer);
        <String>::sse_encode(self.organizations_url, serializer);
        <String>::sse_encode(self.repos_url, serializer);
        <String>::sse_encode(self.events_url, serializer);
        <String>::sse_encode(self.received_events_url, serializer);
        <String>::sse_encode(self.r#type, serializer);
        <bool>::sse_encode(self.site_admin, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::types::config::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.user_agreement, serializer);
        <crate::api::types::config::QualityConfig>::sse_encode(self.quality_config, serializer);
        <Option<crate::api::types::external_api::ExternalApiConfig>>::sse_encode(
            self.external_api,
            serializer,
        );
        <crate::api::types::config::UpdateConfig>::sse_encode(self.update_config, serializer);
        <crate::api::types::config::StorageConfig>::sse_encode(self.storage_config, serializer);
        <Option<crate::api::types::config::WindowConfig>>::sse_encode(
            self.window_config,
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::external_api::ExternalApiConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.file_path, serializer);
        <Option<String>>::sse_encode(self.url, serializer);
        <Option<String>>::sse_encode(self.last_hash, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for Vec<crate::api::music_api::mirror::Artist> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::music_api::mirror::Artist>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::version::Asset> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::version::Asset>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::music_api::mirror::Music> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::music_api::mirror::Music>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::music_api::mirror::MusicAggregator> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::music_api::mirror::MusicAggregator>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::music_api::mirror::MusicChart> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::music_api::mirror::MusicChart>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::music_api::mirror::MusicChartCollection> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::music_api::mirror::MusicChartCollection>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::music_api::mirror::MusicServer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::music_api::mirror::MusicServer>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::music_api::mirror::PlayListSubscription> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::music_api::mirror::PlayListSubscription>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::music_api::mirror::Playlist> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::music_api::mirror::Playlist>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::music_api::mirror::PlaylistCollection> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::music_api::mirror::PlaylistCollection>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::music_api::mirror::PlaylistTag> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::music_api::mirror::PlaylistTag>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::music_api::mirror::PlaylistTagCollection> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::music_api::mirror::PlaylistTagCollection>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::music_api::mirror::Quality> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::music_api::mirror::Quality>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::music_api::mirror::ServerMusicChartCollection> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::music_api::mirror::ServerMusicChartCollection>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::api::music_api::mirror::ServerPlaylistTagCollection> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::music_api::mirror::ServerPlaylistTagCollection>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for crate::api::log::LogLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::log::LogLevel::Debug => 0,
                crate::api::log::LogLevel::Info => 1,
                crate::api::log::LogLevel::Warn => 2,
                crate::api::log::LogLevel::Error => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::log::Logger {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::api::music_api::mirror::Music {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.from_db, serializer);
        <crate::api::music_api::mirror::MusicServer>::sse_encode(self.server, serializer);
        <String>::sse_encode(self.identity, serializer);
        <String>::sse_encode(self.name, serializer);
        <Option<i64>>::sse_encode(self.duration, serializer);
        <Vec<crate::api::music_api::mirror::Artist>>::sse_encode(self.artists, serializer);
        <Option<String>>::sse_encode(self.album, serializer);
        <Option<String>>::sse_encode(self.album_id, serializer);
        <Vec<crate::api::music_api::mirror::Quality>>::sse_encode(self.qualities, serializer);
        <Option<String>>::sse_encode(self.cover, serializer);
    }
}

impl SseEncode for crate::api::music_api::mirror::MusicAggregator {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.artist, serializer);
        <bool>::sse_encode(self.from_db, serializer);
        <Option<i64>>::sse_encode(self.order, serializer);
        <Vec<crate::api::music_api::mirror::Music>>::sse_encode(self.musics, serializer);
        <crate::api::music_api::mirror::MusicServer>::sse_encode(self.default_server, serializer);
    }
}

impl SseEncode for crate::api::music_api::mirror::MusicChart {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <Option<String>>::sse_encode(self.summary, serializer);
        <Option<String>>::sse_encode(self.cover, serializer);
        <String>::sse_encode(self.id, serializer);
    }
}

impl SseEncode for crate::api::music_api::mirror::MusicChartCollection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <Option<String>>::sse_encode(self.summary, serializer);
        <Vec<crate::api::music_api::mirror::MusicChart>>::sse_encode(self.charts, serializer);
    }
}

impl SseEncode for crate::api::music_api::mirror::MusicDataType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::music_api::mirror::MusicDataType::Database => 0,
                crate::api::music_api::mirror::MusicDataType::Playlists => 1,
                crate::api::music_api::mirror::MusicDataType::MusicAggregators => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::music_api::mirror::MusicServer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::music_api::mirror::MusicServer::Kuwo => 0,
                crate::api::music_api::mirror::MusicServer::Netease => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::external_api::ExternalApiConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::external_api::ExternalApiConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::music_api::mirror::MusicServer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::music_api::mirror::MusicServer>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::playinfo::PlayInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::playinfo::PlayInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::music_api::mirror::Playlist> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::music_api::mirror::Playlist>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::version::Release> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::version::Release>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::config::WindowConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::config::WindowConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::api::music_api::mirror::PlayListSubscription>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::api::music_api::mirror::PlayListSubscription>>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for crate::api::types::playinfo::PlayInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.uri, serializer);
        <crate::api::music_api::mirror::Quality>::sse_encode(self.quality, serializer);
    }
}

impl SseEncode for crate::api::music_api::mirror::PlayListSubscription {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.share, serializer);
    }
}

impl SseEncode for crate::api::music_api::mirror::Playlist {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.from_db, serializer);
        <Option<crate::api::music_api::mirror::MusicServer>>::sse_encode(self.server, serializer);
        <crate::api::music_api::mirror::PlaylistType>::sse_encode(self.type_field, serializer);
        <String>::sse_encode(self.identity, serializer);
        <Option<i64>>::sse_encode(self.collection_id, serializer);
        <String>::sse_encode(self.name, serializer);
        <Option<i64>>::sse_encode(self.order, serializer);
        <Option<String>>::sse_encode(self.summary, serializer);
        <Option<String>>::sse_encode(self.cover, serializer);
        <Option<String>>::sse_encode(self.creator, serializer);
        <Option<String>>::sse_encode(self.creator_id, serializer);
        <Option<i64>>::sse_encode(self.play_time, serializer);
        <Option<i64>>::sse_encode(self.music_num, serializer);
        <Option<Vec<crate::api::music_api::mirror::PlayListSubscription>>>::sse_encode(
            self.subscription,
            serializer,
        );
    }
}

impl SseEncode for crate::api::music_api::mirror::PlaylistCollection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i64>::sse_encode(self.id, serializer);
        <i64>::sse_encode(self.order, serializer);
        <String>::sse_encode(self.name, serializer);
    }
}

impl SseEncode for crate::api::music_api::mirror::PlaylistTag {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.id, serializer);
    }
}

impl SseEncode for crate::api::music_api::mirror::PlaylistTagCollection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <Vec<crate::api::music_api::mirror::PlaylistTag>>::sse_encode(self.tags, serializer);
    }
}

impl SseEncode for crate::api::music_api::mirror::PlaylistType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::music_api::mirror::PlaylistType::UserPlaylist => 0,
                crate::api::music_api::mirror::PlaylistType::Album => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::music_api::mirror::PlaylistUpdateSubscriptionResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, String)>>::sse_encode(self.errors, serializer);
    }
}

impl SseEncode for crate::api::music_api::mirror::Quality {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.summary, serializer);
        <Option<String>>::sse_encode(self.bitrate, serializer);
        <Option<String>>::sse_encode(self.format, serializer);
        <Option<String>>::sse_encode(self.size, serializer);
    }
}

impl SseEncode for crate::api::types::config::QualityConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::config::QualityOption>::sse_encode(self.wifi_auto_quality, serializer);
        <crate::api::types::config::QualityOption>::sse_encode(
            self.mobile_auto_quality,
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::config::QualityOption {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::config::QualityOption::Highest => 0,
                crate::api::types::config::QualityOption::High => 1,
                crate::api::types::config::QualityOption::Medium => 2,
                crate::api::types::config::QualityOption::Low => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode
    for (
        Option<crate::api::types::playinfo::PlayInfo>,
        Option<String>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<crate::api::types::playinfo::PlayInfo>>::sse_encode(self.0, serializer);
        <Option<String>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode
    for (
        Option<crate::api::music_api::mirror::Playlist>,
        Vec<crate::api::music_api::mirror::MusicAggregator>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<crate::api::music_api::mirror::Playlist>>::sse_encode(self.0, serializer);
        <Vec<crate::api::music_api::mirror::MusicAggregator>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::api::types::version::Release {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.url, serializer);
        <String>::sse_encode(self.assets_url, serializer);
        <String>::sse_encode(self.upload_url, serializer);
        <String>::sse_encode(self.html_url, serializer);
        <u64>::sse_encode(self.id, serializer);
        <crate::api::types::version::Author>::sse_encode(self.author, serializer);
        <String>::sse_encode(self.node_id, serializer);
        <String>::sse_encode(self.tag_name, serializer);
        <String>::sse_encode(self.target_commitish, serializer);
        <String>::sse_encode(self.name, serializer);
        <bool>::sse_encode(self.draft, serializer);
        <bool>::sse_encode(self.prerelease, serializer);
        <String>::sse_encode(self.created_at, serializer);
        <String>::sse_encode(self.published_at, serializer);
        <Vec<crate::api::types::version::Asset>>::sse_encode(self.assets, serializer);
        <String>::sse_encode(self.tarball_url, serializer);
        <String>::sse_encode(self.zipball_url, serializer);
        <String>::sse_encode(self.body, serializer);
    }
}

impl SseEncode for crate::api::music_api::mirror::ServerMusicChartCollection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::music_api::mirror::MusicServer>::sse_encode(self.server, serializer);
        <Vec<crate::api::music_api::mirror::MusicChartCollection>>::sse_encode(
            self.collections,
            serializer,
        );
    }
}

impl SseEncode for crate::api::music_api::mirror::ServerPlaylistTagCollection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::music_api::mirror::MusicServer>::sse_encode(self.server, serializer);
        <Vec<crate::api::music_api::mirror::PlaylistTagCollection>>::sse_encode(
            self.collections,
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::config::StorageConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.save_cover, serializer);
        <Option<String>>::sse_encode(self.custom_cache_root, serializer);
        <Option<String>>::sse_encode(self.custom_db, serializer);
    }
}

impl SseEncode for crate::api::music_api::mirror::TagPlaylistOrder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::music_api::mirror::TagPlaylistOrder::Hot => 0,
                crate::api::music_api::mirror::TagPlaylistOrder::New => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::api::types::config::UpdateConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.version_auto_update, serializer);
        <bool>::sse_encode(self.external_api_auto_update, serializer);
    }
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::api::types::config::WindowConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.width, serializer);
        <i32>::sse_encode(self.height, serializer);
        <i32>::sse_encode(self.min_width, serializer);
        <i32>::sse_encode(self.min_height, serializer);
        <bool>::sse_encode(self.fullscreen, serializer);
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.8.0.

    // Section: imports

    use super::*;
    use crate::api::music_api::wrapper::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_app_rhyme_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMusicDataJsonWrapper(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MusicDataJsonWrapper>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_app_rhyme_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMusicDataJsonWrapper(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MusicDataJsonWrapper>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.8.0.

    // Section: imports

    use super::*;
    use crate::api::music_api::wrapper::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMusicDataJsonWrapper(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MusicDataJsonWrapper>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMusicDataJsonWrapper(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MusicDataJsonWrapper>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(target_family = "wasm")]
pub use web::*;
