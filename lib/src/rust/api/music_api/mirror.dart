// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.4.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are not used by any `pub` functions: `ArtistVec`, `MusicAggregatorJsonVec`, `PlayListSubscriptionVec`, `PlaylistJsonVec`, `PlaylistJson`, `QualityVec`

class Artist {
  String name;
  PlatformInt64? id;

  Artist({
    required this.name,
    this.id,
  });

  @override
  int get hashCode => name.hashCode ^ id.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Artist &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          id == other.id;
}

class Music {
  final bool fromDb;
  final MusicServer server;
  final String identity;
  String name;
  PlatformInt64? duration;
  List<Artist> artists;
  String? album;
  String? albumId;
  List<Quality> qualities;
  String? cover;

  Music({
    required this.fromDb,
    required this.server,
    required this.identity,
    required this.name,
    this.duration,
    required this.artists,
    this.album,
    this.albumId,
    required this.qualities,
    this.cover,
  });

  /// return the album playlist on first page, and musics on each page
  /// on some music server, the page and limit has no effect, they just return the all musics.
  Future<(Playlist?, List<MusicAggregator>)> getAlbum(
          {required int page, required int limit}) =>
      RustLib.instance.api.crateApiMusicApiMirrorMusicGetAlbum(
          that: this, page: page, limit: limit);

  /// get music cover of specific size
  String? getCover({required int size}) => RustLib.instance.api
      .crateApiMusicApiMirrorMusicGetCover(that: this, size: size);

  Future<String> getLyric() =>
      RustLib.instance.api.crateApiMusicApiMirrorMusicGetLyric(
        that: this,
      );

  Future<void> insertToDb() =>
      RustLib.instance.api.crateApiMusicApiMirrorMusicInsertToDb(
        that: this,
      );

  /// Search music online
  static Future<List<Music>> searchOnline(
          {required List<MusicServer> servers,
          required String content,
          required PlatformInt64 page,
          required PlatformInt64 size}) =>
      RustLib.instance.api.crateApiMusicApiMirrorMusicSearchOnline(
          servers: servers, content: content, page: page, size: size);

  /// 允许外部调用更新音乐的功能
  Future<Music> updateToDb() =>
      RustLib.instance.api.crateApiMusicApiMirrorMusicUpdateToDb(
        that: this,
      );

  @override
  int get hashCode =>
      fromDb.hashCode ^
      server.hashCode ^
      identity.hashCode ^
      name.hashCode ^
      duration.hashCode ^
      artists.hashCode ^
      album.hashCode ^
      albumId.hashCode ^
      qualities.hashCode ^
      cover.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Music &&
          runtimeType == other.runtimeType &&
          fromDb == other.fromDb &&
          server == other.server &&
          identity == other.identity &&
          name == other.name &&
          duration == other.duration &&
          artists == other.artists &&
          album == other.album &&
          albumId == other.albumId &&
          qualities == other.qualities &&
          cover == other.cover;
}

class MusicAggregator {
  final String name;
  final String artist;
  final bool fromDb;
  PlatformInt64? order;
  List<Music> musics;
  MusicServer defaultServer;

  MusicAggregator({
    required this.name,
    required this.artist,
    required this.fromDb,
    this.order,
    required this.musics,
    required this.defaultServer,
  });

  Future<void> changeDefaultServerInDb({required MusicServer server}) =>
      RustLib.instance.api
          .crateApiMusicApiMirrorMusicAggregatorChangeDefaultServerInDb(
              that: this, server: server);

  Future<void> delFromDb() =>
      RustLib.instance.api.crateApiMusicApiMirrorMusicAggregatorDelFromDb(
        that: this,
      );

  Future<MusicAggregator> fetchServerOnline(
          {required List<MusicServer> servers}) =>
      RustLib.instance.api
          .crateApiMusicApiMirrorMusicAggregatorFetchServerOnline(
              that: this, servers: servers);

  static Future<MusicAggregator> fromMusic({required Music music}) =>
      RustLib.instance.api
          .crateApiMusicApiMirrorMusicAggregatorFromMusic(music: music);

  String identity() =>
      RustLib.instance.api.crateApiMusicApiMirrorMusicAggregatorIdentity(
        that: this,
      );

  Future<void> saveToDb() =>
      RustLib.instance.api.crateApiMusicApiMirrorMusicAggregatorSaveToDb(
        that: this,
      );

  static Future<List<MusicAggregator>> searchOnline(
          {required List<MusicAggregator> aggs,
          required List<MusicServer> servers,
          required String content,
          required PlatformInt64 page,
          required PlatformInt64 size}) =>
      RustLib.instance.api.crateApiMusicApiMirrorMusicAggregatorSearchOnline(
          aggs: aggs,
          servers: servers,
          content: content,
          page: page,
          size: size);

  Future<void> updateOrderToDb({required PlatformInt64 playlistId}) =>
      RustLib.instance.api.crateApiMusicApiMirrorMusicAggregatorUpdateOrderToDb(
          that: this, playlistId: playlistId);

  @override
  int get hashCode =>
      name.hashCode ^
      artist.hashCode ^
      fromDb.hashCode ^
      order.hashCode ^
      musics.hashCode ^
      defaultServer.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MusicAggregator &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          artist == other.artist &&
          fromDb == other.fromDb &&
          order == other.order &&
          musics == other.musics &&
          defaultServer == other.defaultServer;
}

enum MusicDataType {
  database,
  playlists,
  musicAggregators,
  ;
}

enum MusicServer {
  kuwo,
  netease,
  ;

  static List<MusicServer> all() =>
      RustLib.instance.api.crateApiMusicApiMirrorMusicServerAll();

  static BigInt length() =>
      RustLib.instance.api.crateApiMusicApiMirrorMusicServerLength();

  @override
  String toString() =>
      RustLib.instance.api.crateApiMusicApiMirrorMusicServerToString(
        that: this,
      );
}

class PlayListSubscription {
  String name;
  String share;

  PlayListSubscription({
    required this.name,
    required this.share,
  });

  @override
  int get hashCode => name.hashCode ^ share.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PlayListSubscription &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          share == other.share;
}

class Playlist {
  final bool fromDb;
  final MusicServer? server;
  final PlaylistType typeField;
  final String identity;
  String name;
  PlatformInt64? order;
  String? summary;
  String? cover;
  final String? creator;
  final String? creatorId;
  final PlatformInt64? playTime;
  final PlatformInt64? musicNum;
  List<PlayListSubscription>? subscription;

  Playlist({
    required this.fromDb,
    this.server,
    required this.typeField,
    required this.identity,
    required this.name,
    this.order,
    this.summary,
    this.cover,
    this.creator,
    this.creatorId,
    this.playTime,
    this.musicNum,
    this.subscription,
  });

  /// add playlist music aggregator junction to db
  /// this will also add the music and music aggregators to the db
  Future<void> addAggsToDb({required List<MusicAggregator> musicAggs}) =>
      RustLib.instance.api.crateApiMusicApiMirrorPlaylistAddAggsToDb(
          that: this, musicAggs: musicAggs);

  /// delete a playlist from db
  /// this will also delete all junctions between the playlist and music
  Future<void> delFromDb() =>
      RustLib.instance.api.crateApiMusicApiMirrorPlaylistDelFromDb(
        that: this,
      );

  Future<void> delMusicAgg({required String musicAggIdentity}) =>
      RustLib.instance.api.crateApiMusicApiMirrorPlaylistDelMusicAgg(
          that: this, musicAggIdentity: musicAggIdentity);

  /// Fetch musics from playlist
  Future<List<MusicAggregator>> fetchMusicsOnline(
          {required int page, required int limit}) =>
      RustLib.instance.api.crateApiMusicApiMirrorPlaylistFetchMusicsOnline(
          that: this, page: page, limit: limit);

  /// find db playlist by primary key `id`
  static Future<Playlist?> findInDb({required PlatformInt64 id}) =>
      RustLib.instance.api.crateApiMusicApiMirrorPlaylistFindInDb(id: id);

  /// get playlist cover of specific size
  String? getCover({required int size}) => RustLib.instance.api
      .crateApiMusicApiMirrorPlaylistGetCover(that: this, size: size);

  /// get playlists from db
  static Future<List<Playlist>> getFromDb() =>
      RustLib.instance.api.crateApiMusicApiMirrorPlaylistGetFromDb();

  /// get a playlist from share link
  static Future<Playlist> getFromShare({required String share}) =>
      RustLib.instance.api
          .crateApiMusicApiMirrorPlaylistGetFromShare(share: share);

  /// get all music aggregators from db
  Future<List<MusicAggregator>> getMusicsFromDb() =>
      RustLib.instance.api.crateApiMusicApiMirrorPlaylistGetMusicsFromDb(
        that: this,
      );

  Future<PlatformInt64> insertToDb() =>
      RustLib.instance.api.crateApiMusicApiMirrorPlaylistInsertToDb(
        that: this,
      );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<Playlist> newInstance(
          {required String name,
          String? summary,
          String? cover,
          required List<PlayListSubscription> subscriptions}) =>
      RustLib.instance.api.crateApiMusicApiMirrorPlaylistNew(
          name: name,
          summary: summary,
          cover: cover,
          subscriptions: subscriptions);

  /// Search playlist online
  static Future<List<Playlist>> searchOnline(
          {required List<MusicServer> servers,
          required String content,
          required PlatformInt64 page,
          required PlatformInt64 size}) =>
      RustLib.instance.api.crateApiMusicApiMirrorPlaylistSearchOnline(
          servers: servers, content: content, page: page, size: size);

  /// update playlist music aggregator of subscribed playlist into db playlist
  Future<PlaylistUpdateSubscriptionResult> updateSubscription() =>
      RustLib.instance.api.crateApiMusicApiMirrorPlaylistUpdateSubscription(
        that: this,
      );

  /// update db playlist info
  Future<Playlist> updateToDb() =>
      RustLib.instance.api.crateApiMusicApiMirrorPlaylistUpdateToDb(
        that: this,
      );

  @override
  int get hashCode =>
      fromDb.hashCode ^
      server.hashCode ^
      typeField.hashCode ^
      identity.hashCode ^
      name.hashCode ^
      order.hashCode ^
      summary.hashCode ^
      cover.hashCode ^
      creator.hashCode ^
      creatorId.hashCode ^
      playTime.hashCode ^
      musicNum.hashCode ^
      subscription.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Playlist &&
          runtimeType == other.runtimeType &&
          fromDb == other.fromDb &&
          server == other.server &&
          typeField == other.typeField &&
          identity == other.identity &&
          name == other.name &&
          order == other.order &&
          summary == other.summary &&
          cover == other.cover &&
          creator == other.creator &&
          creatorId == other.creatorId &&
          playTime == other.playTime &&
          musicNum == other.musicNum &&
          subscription == other.subscription;
}

enum PlaylistType {
  userPlaylist,
  album,
  ;
}

class PlaylistUpdateSubscriptionResult {
  final List<(String, String)> errors;

  const PlaylistUpdateSubscriptionResult({
    required this.errors,
  });

  @override
  int get hashCode => errors.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PlaylistUpdateSubscriptionResult &&
          runtimeType == other.runtimeType &&
          errors == other.errors;
}

class Quality {
  final String summary;
  final String? bitrate;
  final String? format;
  final String? size;

  const Quality({
    required this.summary,
    this.bitrate,
    this.format,
    this.size,
  });

  @override
  int get hashCode =>
      summary.hashCode ^ bitrate.hashCode ^ format.hashCode ^ size.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Quality &&
          runtimeType == other.runtimeType &&
          summary == other.summary &&
          bitrate == other.bitrate &&
          format == other.format &&
          size == other.size;
}
